"""
Resources:
- https://www.youtube.com/watch?v=6JVqutwtzmo
- https://en.wikipedia.org/wiki/Viterbi_algorithm
- CLRS Ch.15

Problem (Speech Recognition):
    - Given a directed graph G = (V,E), each edge (u,v) is labeled with a sound sigma(u,v) from a finite set of sounds (S=[sigma1...sigmak])
        and a probability p(u,v) of traversing u --> v and generating the sound sigma(u,v).
    - Each path in the graph starting from a distinguished vertex v0 corresponds to a possible sequence of sounds produced by the model.
    - We define the label of a directed path to be the concatenation of the labels of the edges on that path.
    - The probability of a path is equal to the product of the probabilities of the path.
    - GOAL: Find the most probable path that has S as its label.

Optimal Substructure:

OPT(X[1...j]) = max{ OPT(X[1...j-1] + dist(j-1, j) }

Proof:

CLAIM: The optimal path from X[1...j] was generated by finding the most probable path such that X[1..j-1] + dist(j-1, j) is better than
        all other qualifying paths to j.

- Assume that we constructed an optimal path to j using the method above.
- Imagine that we had another path (P*) such that the path X[1...j-1*] + dist(j-1*, j) is more optimal that our original P.
- We could just replace the old X[1...j-1] with the new one X[1...j-1*] and construct an even more optimal one. Contradicting our purported optimality.
"""

import numpy as np
import math
import json


# Data Needed: Adjacency Matrix (Stores Probabilities & Sound labels)

class Viterbi:
    def __init__(self, edges):
        self.edges = edges
        self.num_vertices = len(set(set(list(map(lambda x: x[0], edges))).union(set(list(map(lambda x: x[1], edges))))))
        self.num_sounds = len(set(list(map(lambda x: x[2], edges))))
        self.G = np.zeros(shape=(self.num_vertices, self.num_vertices)) # Adjacency Matrix that stores sound & prob
        self.S = {sound: {} for sound in range(self.num_sounds)} # Table that maps sound --> v in an edge (u,v)
        # Build Tables for storing optimal path where:
        #   - T1[i,j] = Path Probability for V_0 -> node(j) to generate sound (i)
        #   - T2[i,j] = Last node on path to node(j) that generated sound (i)
        self.T1 = np.zeros(shape=(self.num_sounds, self.num_vertices))  # stores probs
        self.T2 = np.zeros(shape=(self.num_sounds, self.num_vertices))  # stores last node

    def find_sound_and_prob(self, u, v):
        value = math.floor(self.G[u - 1, v - 1])
        prob = self.G[u - 1, v - 1] - value

        return value, round(prob, 3)

    def init_tables(self):
        # 1. Complete base case for G
        for edge in self.edges:
            self.G[edge[0] - 1, edge[1] - 1] = edge[2] + edge[3]

        # 2. Complete base case for S
        for edge in edges:
            self.S[edge[2] - 1][edge[1] - 1] = True

        # 3. Complete base case for T1 & T2
        for j in range(self.num_vertices):
            sound, prob = self.find_sound_and_prob(u=1, v=j + 1)
            if sound == 1:
                self.T1[0, j] = prob
                self.T2[0, j] = 0

    def find_optimal_path(self):
        for i in range(self.num_sounds - 1):
            for j in range(self.num_vertices):
                if self.T1[i, j] > 0:  # This means there is a connection from v_0 to this node that generates this sound (i)
                    for next_sound_node in self.S[i + 1].keys():
                        sound, prob = self.find_sound_and_prob(u=j + 1, v=next_sound_node + 1)
                        if sound == i + 2 and prob > 0: # if there is a connection from node j to this node that generates sound (i)
                            path_prob = self.T1[i, j] * prob
                            if path_prob > self.T1[i + 1, next_sound_node]:
                                self.T1[i + 1, next_sound_node] = path_prob
                                self.T2[i + 1, next_sound_node] = j

    def reconstruct_solution(self):
        PATH = []

        max_prob = 0
        max_node = None
        for j in range(self.num_vertices):
            if self.T1[self.num_sounds - 1, j] > max_prob:
                max_prob = self.T1[self.num_sounds - 1, j]
                max_node = j

        PATH.insert(0, int(max_node))

        for i in range(self.num_sounds - 1, -1, -1):
            max_node = self.T2[i, int(max_node)]
            PATH.insert(0, int(max_node))

        return PATH

    def compute(self):
        self.init_tables()
        self.find_optimal_path()
        optimal_path = self.reconstruct_solution()
        return optimal_path


if __name__ == '__main__':
    edges = [(1, 2, 1, 0.3), (1, 3, 2, 0.2), (1, 4, 1, 0.5), (2, 5, 2, 0.4), (2, 3, 2, 0.6), (3, 4, 3, 0.3),
             (3, 6, 3, 0.7),
             (4, 6, 4, 0.6), (4, 9, 4, 0.4), (5, 6, 3, 0.2), (5, 7, 1, 0.8), (6, 7, 4, 0.5), (6, 8, 1, 0.5),
             (7, 9, 2, 1), (8, 9, 2, 1)]

    viterbi = Viterbi(edges=edges)
    optimal_path = viterbi.compute()
    print(optimal_path)






